<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Model Gallery | QuadSpectat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,600,700&display=swap">
  <!-- ... your CSS unchanged ... -->
  <!-- [CSS omitted for brevity: use exactly your code above!] -->
</head>
<body>
  <div id="cesiumContainer"></div>
  <button id="menuBtn">Menu</button>
  <div id="sidebar">
    <!-- ... sidebar unchanged ... -->
  </div>
  <div id="toolbar">
    <a href="#" id="backBtn">Back</a>
    <button id="recenterBtn">Recenter</button>
    <button id="fullscreenBtn">Fullscreen</button>
    <button id="distanceBtn">Distance</button>
    <button id="areaBtn">Area</button>
    <button id="volumeBtn">Volume</button>
    <button id="clearBtn">Clear</button>
  </div>
  <div id="measurement-display">
    <div>Select a tool to begin.</div>
    <ul id="measurement-list"></ul>
    <div id="measurement-total"></div>
  </div>
  <script>
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmYTNlODhkNC0zOTNlLTRkMmEtODU2MS04ZGQ3NDFkNGU4NmQiLCJpZCI6MTE5NjI3LCJpYXQiOjE2NzIxNjg2MjN9.iQ-WY4qZZoK8NCgheHh1m0gM4GBWsaMl7UTMcufyl7Q';
    const models = [
      {
        id: "Barkay",
        name: "Barkay 2025",
        url: "https://quadspectat-models.fra1.cdn.digitaloceanspaces.com/Barkay%202025/Scene/Barkai_2025_Cesium.json"
      },
      {
        id: "Givat Haviva",
        name: "Givat Haviva 2025",
        url: "https://quadspectat-models.fra1.cdn.digitaloceanspaces.com/Givat%20Haviva/Scene/Cesium.json"
      }
    ];
    let viewer, currentTileset = null, currentModelId = null;
    let initialLighting = {};

    document.addEventListener('DOMContentLoaded', async () => {
      setupMenu();
      await setupCesium();
      setupModelGallery();
      setupDataLayers();
      setupLightingControls();
      setupShareControls();
      setupToolbar();
      setupMeasurementTools(); // <-- FIXED: make sure this is called!
      loadModelFromUrlOrDefault();
    });

    // ... rest of your code unchanged ...

    // --- FIXED MEASUREMENT TOOLS ---
    function setupMeasurementTools() {
      const display = document.getElementById('measurement-display');
      const listElem = document.getElementById('measurement-list');
      const totalElem = document.getElementById('measurement-total');
      let handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas); // FIX: use viewer.scene.canvas!
      let activeTool = null, points = [];
      let measurements = [];
      let tempEntities = [];
      const buttons = {
        distance: document.getElementById('distanceBtn'),
        area: document.getElementById('areaBtn'),
        volume: document.getElementById('volumeBtn'),
      };
      const COLORS = {
        distance: Cesium.Color.fromCssColorString(getComputedStyle(document.documentElement).getPropertyValue('--distance-color') || "#c1f120"),
        area: Cesium.Color.fromCssColorString(getComputedStyle(document.documentElement).getPropertyValue('--area-color') || "#43a9ff"),
        volume: Cesium.Color.fromCssColorString(getComputedStyle(document.documentElement).getPropertyValue('--volume-color') || "#ff2d50"),
      };

      function clear() {
        if (activeTool) buttons[activeTool].classList.remove('active');
        activeTool = null; points = [];
        tempEntities.forEach(ent => viewer.entities.remove(ent));
        tempEntities = [];
        if (dynamicEntity) { viewer.entities.remove(dynamicEntity); dynamicEntity = null; }
        removeDynamicDistanceLabel();
      }
      function clearAll() {
        clear();
        measurements.forEach(m => m.entities.forEach(ent=>viewer.entities.remove(ent)));
        measurements = [];
        redrawList();
        display.querySelector('div').textContent = 'Select a tool to begin.';
      }
      function activateTool(tool) {
        if (activeTool === tool) { clear(); return; }
        clear(); activeTool = tool; buttons[tool].classList.add('active');
        display.querySelector('div').textContent = `Click to measure ${tool}.`;
      }
      buttons.distance.onclick = () => activateTool('distance');
      buttons.area.onclick = () => activateTool('area');
      buttons.volume.onclick = () => activateTool('volume');
      document.getElementById('clearBtn').onclick = clearAll;
      let dynamicEntity = null;

      handler.setInputAction((event) => {
        if (!activeTool) return;
        const pos = viewer.scene.pickPosition(event.position || event.endPosition);
        if (!Cesium.defined(pos)) return;
        points.push(pos);
        const dot = viewer.entities.add({ position: pos, point: { pixelSize: 8, color: COLORS[activeTool], disableDepthTestDistance: 1e9 } });
        tempEntities.push(dot);
        if (activeTool === 'distance' && points.length === 2) finalize();
        if ((activeTool === 'area' || activeTool === 'volume') && points.length > 2) {
          // allow area/volume to finish with double-click or right click
          display.querySelector('div').textContent = 'Double-tap or right-click to finish.';
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      handler.setInputAction((event) => {
        if (activeTool === 'area' || activeTool === 'volume') {
          if (points.length >= 3) finalize();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

      handler.setInputAction((event) => {
        if (!activeTool || points.length === 0) return;
        const pos = viewer.scene.pickPosition(event.endPosition || event.position);
        if (!Cesium.defined(pos)) return;
        if (activeTool === 'distance') {
          if (!dynamicEntity) dynamicEntity = viewer.entities.add({ polyline: { positions: [points[0]], width: 3, material: COLORS[activeTool].withAlpha(0.5) }});
          dynamicEntity.polyline.positions = [points[0], pos];
          addOrUpdateDynamicDistanceLabel(points[0], pos, Cesium.Cartesian3.distance(points[0], pos), COLORS[activeTool]);
        } else if (activeTool === 'area' || activeTool === 'volume') {
          if (!dynamicEntity) dynamicEntity = viewer.entities.add({ polygon: { hierarchy: {}, material: COLORS[activeTool].withAlpha(0.5) } });
          dynamicEntity.polygon.hierarchy = new Cesium.PolygonHierarchy([...points, pos]);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      let dynamicDistanceLabel = null;
      function addOrUpdateDynamicDistanceLabel(p1, p2, value, color) {
        if (!dynamicDistanceLabel) {
          dynamicDistanceLabel = viewer.entities.add({
            position: Cesium.Cartesian3.midpoint(p1, p2, new Cesium.Cartesian3()),
            label: {
              text: value.toFixed(2) + " m",
              font: "bold 18px sans-serif",
              fillColor: color,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              outlineWidth: 3,
              outlineColor: Cesium.Color.BLACK,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              disableDepthTestDistance: 1e9,
              scale: 1.1
            }
          });
        } else {
          dynamicDistanceLabel.position = Cesium.Cartesian3.midpoint(p1, p2, new Cesium.Cartesian3());
          dynamicDistanceLabel.label.text = value.toFixed(2) + " m";
          dynamicDistanceLabel.label.fillColor = color;
        }
      }
      function removeDynamicDistanceLabel() {
        if (dynamicDistanceLabel) {
          viewer.entities.remove(dynamicDistanceLabel);
          dynamicDistanceLabel = null;
        }
      }
      function finalize() {
        let entity, text = '', value = 0, type = activeTool, color = COLORS[activeTool];
        let entities = [...tempEntities];
        let labelEntity = null;
        if (activeTool === 'distance') {
          entity = viewer.entities.add({ polyline: { positions: points, width: 3, material: color } });
          value = Cesium.Cartesian3.distance(points[0], points[1]);
          text = `Distance: ${value.toFixed(2)} m`;
          entities.push(entity);
          labelEntity = viewer.entities.add({
            position: Cesium.Cartesian3.midpoint(points[0], points[1], new Cesium.Cartesian3()),
            label: {
              text: value.toFixed(2) + " m",
              font: "bold 18px sans-serif",
              fillColor: color,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              outlineWidth: 3,
              outlineColor: Cesium.Color.BLACK,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              disableDepthTestDistance: 1e9,
              scale: 1.1
            }
          });
          entities.push(labelEntity);
        } else if (activeTool === 'area' || activeTool === 'volume') {
          value = calculate3DArea(points);
          text = `Surface Area: ${value.toFixed(2)} m²`;
          if (activeTool === 'volume') {
            const cartographics = points.map(p => Cesium.Cartographic.fromCartesian(p));
            const minHeight = Math.min(...cartographics.map(p => p.height));
            const maxHeight = Math.max(...cartographics.map(p => p.height));
            const vol = value * (maxHeight - minHeight);
            text += ` | Volume: ${vol.toFixed(2)} m³`;
            value = vol;
          }
          entity = viewer.entities.add({ polygon: { hierarchy: new Cesium.PolygonHierarchy(points), material: color.withAlpha(0.5) } });
          entities.push(entity);
          const centroid = polygonCentroid(points);
          let labelText = activeTool === "area"
            ? `${calculate3DArea(points).toFixed(2)} m²`
            : `Area: ${calculate3DArea(points).toFixed(2)} m²\nVol: ${value.toFixed(2)} m³`;
          labelEntity = viewer.entities.add({
            position: centroid,
            label: {
              text: labelText,
              font: "bold 16px sans-serif",
              fillColor: color,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              outlineWidth: 3,
              outlineColor: Cesium.Color.BLACK,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              disableDepthTestDistance: 1e9,
              scale: 1.05
            }
          });
          entities.push(labelEntity);
        }
        if (dynamicEntity) { viewer.entities.remove(dynamicEntity); dynamicEntity = null; }
        removeDynamicDistanceLabel();
        measurements.push({type, value, entities, text, color});
        tempEntities = [];
        redrawList();
        clear();
        points = [];
      }
      function redrawList() {
        listElem.innerHTML = '';
        let total = 0;
        let totalLabel = '';
        if(measurements.length === 0) {
          totalElem.textContent = '';
          return;
        }
        measurements.forEach((m, i) => {
          const li = document.createElement('li');
          li.textContent = m.text;
          li.setAttribute('data-type', m.type);
          li.style.borderLeftColor = m.color.toCssColorString();
          const delBtn = document.createElement('button');
          delBtn.textContent = '✕';
          delBtn.onclick = () => {
            m.entities.forEach(ent=>viewer.entities.remove(ent));
            measurements.splice(i,1);
            redrawList();
          };
          li.appendChild(delBtn);
          listElem.appendChild(li);
          total += m.value;
          if (!totalLabel) totalLabel = m.type==='distance' ? 'Total Distance' : (m.type==='area' ? 'Total Area' : (m.type==='volume' ? 'Total Volume' : 'Total'));
        });
        totalElem.textContent = `${totalLabel}: ${total.toFixed(2)} ${measurements[0].type==='distance'?'m':(measurements[0].type==='area'?'m²':'m³')}`;
      }
      function calculate3DArea(positions) {
        if (positions.length < 3) return 0;
        const origin = positions[0];
        const enu = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
        const inv = Cesium.Matrix4.inverseTransformation(enu, new Cesium.Matrix4());
        const pts2d = positions.map(c => {
          const t = Cesium.Matrix4.multiplyByPoint(inv, c, new Cesium.Cartesian3());
          return {x: t.y, y: t.z};
        });
        let area = 0, n = pts2d.length;
        for (let i = 0; i < n; i++) {
          const {x: x0, y: y0} = pts2d[i], {x: x1, y: y1} = pts2d[(i+1)%n];
          area += (x0 * y1 - x1 * y0);
        }
        return Math.abs(area / 2);
      }
      function polygonCentroid(positions) {
        let x=0,y=0,z=0;
        positions.forEach(p=>{
          x += p.x; y += p.y; z += p.z;
        });
        return new Cesium.Cartesian3(x/positions.length, y/positions.length, z/positions.length);
      }
    }
    // ... rest of your code unchanged ...
  </script>
</body>
</html>